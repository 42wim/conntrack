package conntrack

import (
	"fmt"

	"github.com/ti-mo/netfilter"
)

// UnmarshalAttributes calls unmarshal operations on a list of netfilter.Attributes.
// It returns a map of AttributeTypes to their respective values. Each attribute type should only occur once in the list,
// since multiple occurrences will overwrite each other.
func UnmarshalAttributes(attrs []netfilter.Attribute, filter AttributeFilter) (map[AttributeType]Attribute, error) {

	// Pre-allocate output slice so it doesn't have to be grown every append()
	ra := make(map[AttributeType]Attribute, len(attrs))

	for _, attr := range attrs {

		// Skip decoding the attribute if the AttributeType's bit is not enabled in filter.
		if !filter.Check(AttributeType(attr.Type)) {
			continue
		}

		var err error

		ra[AttributeType(attr.Type)], err = UnmarshalAttribute(attr)
		if err != nil {
			return nil, err
		}

	}

	return ra, nil
}

// UnmarshalAttribute unmarshals a netfilter attribute into a conntrack attribute.
func UnmarshalAttribute(attr netfilter.Attribute) (Attribute, error) {

	switch at := AttributeType(attr.Type); at {

	// CTA_TIMEOUT is the time until the Conntrack entry is automatically destroyed.
	// CTA_ID is the tuple hash value generated by the kernel. It can be relied on for flow identification.
	// CTA_USE's purpose is shrouded in mystery.
	// CTA_MARK is the connection's connmark
	// CTA_MARK_MASK is never sent by the kernel, but can be used for kernel-space dump filtering!
	case CTATimeout, CTAID, CTAUse, CTAMark, CTAMarkMask:
		var i Num32
		if err := (&i).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &i, nil

	// CTA_ZONE describes the Conntrack zone the flow is placed in. This can be combined with a CTA_TUPLE_ZONE
	// to specify which zone an event originates from.
	case CTAZone:
		var i Num16
		if err := (&i).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &i, nil

	// CTA_LABELS is a binary bitfield attached to a connection that is sent in
	// events when changed, as well as in response to dump queries.
	// CTA_LABELS_MASK is never sent by the kernel, but it can be used
	// in set / update queries to mask label operations on the kernel state table.
	// it needs to be exactly as wide as the CTA_LABELS field it intends to mask.
	case CTALabels, CTALabelsMask:
		var b Bitfield
		(&b).UnmarshalAttribute(attr) // Does not return errors
		return &b, nil

	// CTA_TUPLE_* attributes are nested and contain source and destination values for:
	// - the IPv4/IPv6 addresses involved
	// - ports used in the connection
	// - (optional) the Conntrack Zone of the originating/replying side of the flow
	case CTATupleOrig, CTATupleReply, CTATupleMaster:
		var tpl Tuple
		if err := (&tpl).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &tpl, nil

	// CTA_STATUS is a bitfield of the state of the connection
	// (eg. if packets are seen in both directions, etc.)
	case CTAStatus:
		var sta Status
		if err := (&sta).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &sta, nil

	// CTA_PROTOINFO is sent for TCP, DCCP and SCTP protocols only. It conveys extra metadata
	// about the state flags seen on the wire. Update events are sent when these change.
	case CTAProtoInfo:
		var pi ProtoInfo
		if err := (&pi).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &pi, nil

	case CTAHelp:
		var hlp Helper
		if err := (&hlp).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &hlp, nil

	// CTA_COUNTERS_* attributes are nested and contain byte and packet counters for flows in either direction.
	case CTACountersOrig, CTACountersReply:
		var ctr Counter
		if err := (&ctr).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &ctr, nil

	// CTA_SECCTX is the SELinux security context of a Conntrack entry.
	case CTASecCtx:
		var sctx Security
		if err := (&sctx).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &sctx, nil

	// CTA_TIMESTAMP is a nested attribute that describes the start and end timestamp of a flow.
	// It is sent by the kernel with dumps and DESTROY events.
	case CTATimestamp:
		var ts Timestamp
		if err := (&ts).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &ts, nil

	// CTA_SEQADJ_* is generalized TCP window adjustment metadata. It is not (yet) emitted in Conntrack events.
	// The reason for its introduction is outlined in https://lwn.net/Articles/563151.
	// Patch set is at http://www.spinics.net/lists/netdev/msg245785.html.
	case CTASeqAdjOrig, CTASeqAdjReply:
		var sa SequenceAdjust
		if err := (&sa).UnmarshalAttribute(attr); err != nil {
			return nil, err
		}
		return &sa, nil

	default:
		return nil, fmt.Errorf(errAttributeUnknown, at)
	}
}
