package conntrack

import (
	"fmt"

	"github.com/ti-mo/netfilter"
)

// UnmarshalAttributes calls unmarshal operations on a list of netfilter.Attributes.
// It returns a map of AttributeTypes to their respective values. Each attribute type should only occur once in the list,
// since multiple occurrences will overwrite each other.
func UnmarshalAttributes(attrs []netfilter.Attribute, filter AttributeFilter) (map[AttributeType]interface{}, error) {

	ra := make(map[AttributeType]interface{})

	for _, attr := range attrs {

		// Skip decoding the attribute if the AttributeType's bit is not enabled in filter.
		if !filter.Check(AttributeType(attr.Type)) {
			continue
		}

		switch at := AttributeType(attr.Type); at {

		// CTA_TIMEOUT is the time until the Conntrack entry is automatically destroyed.
		// CTA_ID is the tuple hash value generated by the kernel. It can be relied on for flow identification.
		// CTA_USE's purpose is shrouded in mystery.
		// CTA_MARK is the connection's connmark
		// CTA_MARK_MASK is never sent by the kernel, but can be used for kernel-space dump filtering!
		case CTATimeout, CTAID, CTAUse, CTAMark, CTAMarkMask:
			if len(attr.Data) != 4 {
				return nil, errIncorrectSize
			}
			ra[at] = attr.Uint32()

		// CTA_ZONE describes the Conntrack zone the flow is placed in. This can be combined with a CTA_TUPLE_ZONE
		// to specify which zone an event originates from.
		case CTAZone:
			if len(attr.Data) != 2 {
				return nil, errIncorrectSize
			}
			ra[at] = attr.Uint16()

		// CTA_LABELS is a binary bitfield attached to a connection that is sent in
		// events when changed, as well as in response to dump queries.
		// CTA_LABELS_MASK is never sent by the kernel, but it can be used
		// in set / update queries to mask label operations on the kernel state table.
		// it needs to be exactly as wide as the CTA_LABELS field it intends to mask.
		case CTALabels, CTALabelsMask:
			ra[at] = attr.Data

		// CTA_TUPLE_* attributes are nested and contain source and destination values for:
		// - the IPv4/IPv6 addresses involved
		// - ports used in the connection
		// - (optional) the Conntrack Zone of the originating/replying side of the flow
		case CTATupleOrig, CTATupleReply, CTATupleMaster:
			var tpl Tuple
			if err := (&tpl).UnmarshalAttribute(attr); err != nil {
				return nil, err
			}
			ra[at] = tpl

		// CTA_STATUS is a bitfield of the state of the connection
		// (eg. if packets are seen in both directions, etc.)
		case CTAStatus:
			var sta Status
			if err := (&sta).UnmarshalAttribute(attr); err != nil {
				return nil, err
			}
			ra[at] = sta

		// CTA_PROTOINFO is sent for TCP, DCCP and SCTP protocols only. It conveys extra metadata
		// about the state flags seen on the wire. Update events are sent when these change.
		case CTAProtoInfo:
			var pi ProtoInfo
			if err := (&pi).UnmarshalAttribute(attr); err != nil {
				return nil, err
			}
			ra[at] = pi

		case CTAHelp:
			var hlp Helper
			if err := (&hlp).UnmarshalAttribute(attr); err != nil {
				return nil, err
			}
			ra[at] = hlp

		// CTA_COUNTERS_* attributes are nested and contain byte and packet counters for flows in either direction.
		case CTACountersOrig, CTACountersReply:
			var ctr Counter
			if err := (&ctr).UnmarshalAttribute(attr); err != nil {
				return nil, err
			}
			ra[at] = ctr

		// CTA_SECCTX is the SELinux security context of a Conntrack entry.
		case CTASecCtx:
			var sctx Security
			if err := (&sctx).UnmarshalAttribute(attr); err != nil {
				return nil, err
			}
			ra[at] = sctx

		// CTA_TIMESTAMP is a nested attribute that describes the start and end timestamp of a flow.
		// It is sent by the kernel with dumps and DESTROY events.
		case CTATimestamp:
			var ts Timestamp
			if err := (&ts).UnmarshalAttribute(attr); err != nil {
				return nil, err
			}
			ra[at] = ts

		// CTA_SEQADJ_* is generalized TCP window adjustment metadata. It is not (yet) emitted in Conntrack events.
		// The reason for its introduction is outlined in https://lwn.net/Articles/563151.
		// Patch set is at http://www.spinics.net/lists/netdev/msg245785.html.
		case CTASeqAdjOrig, CTASeqAdjReply:
			var sa SequenceAdjust
			if err := (&sa).UnmarshalAttribute(attr); err != nil {
				return nil, err
			}
			ra[at] = sa

		default:
			return nil, fmt.Errorf(errAttributeUnknown, at)
		}
	}

	return ra, nil
}
